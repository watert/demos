{
  "name": "lazy.js",
  "description": "Like Underscore, but lazier",
  "version": "0.1.0",
  "homepage": "http://dtao.github.io/lazy.js/",
  "author": {
    "name": "Dan Tao",
    "email": "daniel.tao@gmail.com",
    "url": "http://philosopherdeveloper.com"
  },
  "main": "lazy.node.js",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/dtao/lazy.js.git"
  },
  "bugs": {
    "url": "https://github.com/dtao/lazy.js/issues"
  },
  "keywords": [
    "lazy",
    "functional",
    "performance",
    "speed",
    "util"
  ],
  "devDependecies": {
    "jasmine-node": "1.7.x",
    "jsdoc": "3.2.x"
  },
  "scripts": {
    "test": "jasmine-node spec/node_spec.js"
  },
  "readme": "Like Underscore, but lazier\n===========================\n\n[![Build Status](https://travis-ci.org/dtao/lazy.js.png?branch=master)](https://travis-ci.org/dtao/lazy.js)\n\n**Lazy.js** it a utility library for JavaScript, similar to [Underscore](http://underscorejs.org/) and [Lo-Dash](http://lodash.com/) but with one important difference: **lazy evaluation** (also known as deferred execution). This can translate to superior performance in many cases, *especially* when dealing with large arrays and/or \"chaining\" together multiple methods. For simple cases (`map`, `filter`, etc.) on small arrays, Lazy's performance should be similar to Underscore or Lo-Dash.\n\nThe following chart illustrates the performance of Lazy.js versus Underscore and Lo-Dash for several common operations using arrays with 10 elements each on Chrome:\n\n![Lazy.js versus Underscore/Lo-Dash](http://i.imgur.com/9vP6sVG.png)\n\nYou can see that the performance difference becomes much more significant for methods that don't require iterating an entire collection (e.g., `indexOf`, `take`) as the arrays get larger:\n\n![Lazy.js versus Underscore/Lo-Dash](http://i.imgur.com/oGPlPug.png)\n\nIntrigued? Great! Now let's look at what you can do with Lazy.js.\n\nIntroduction\n------------\n\nWe'll start with an array containing 1000 integers. Incidentally, generating such an array using Lazy.js is quite trivial:\n\n```javascript\nvar array = Lazy.range(1000).toArray();\n```\n\nNote the `toArray` call; without it, what you'll get from `Lazy.range` won't be an actual *array* but rather a `Lazy.Sequence` object, which you can iterate over using `each`. But we'll get to that in a moment.\n\nNow let's say we want to take the *squares* of each of these numbers, increment them, and then take the first five even results. We'll use these helper functions, to keep the code concise:\n\n```javascript\nfunction square(x) { return x * x; }\nfunction inc(x) { return x + 1; }\nfunction isEven(x) { return x % 2 === 0; }\n```\n\nYes, this is admittedly a very arbitrary goal. (Later I'll get around to thinking of a more realistic scenario.) Anyway, here's one way you might accomplish it using Underscore and its convenient `chain` method:\n\n```javascript\nvar result = _.chain(array).map(square).map(inc).filter(isEven).take(5).value();\n```\n\nThis query does a lot of stuff:\n\n- `map(square)`: iterates over the array and creates a new 1000-element array\n- `map(inc)`: iterates over the new array, creating *another* new 1000-element array\n- `filter(isEven)`: iterates over *that* array, creating yet *another* new (500-element) array\n- `take(5)`: all that just for 5 elements!\n\nSo if performance and/or efficiency were a concern for you, you would probably *not* do things that way using Underscore. Instead, you'd likely go the procedural route:\n\n```javascript\nvar results = [];\nfor (var i = 0; i < array.length; ++i) {\n  var value = (array[i] * array[i]) + 1;\n  if (value % 2 === 0) {\n    results.push(value);\n    if (results.length === 5) {\n      break;\n    }\n  }\n}\n```\n\nThere&mdash;now we we haven't created have any extraneous arrays, and we did all of the work in one iteration. Any problems?\n\nWell, yeah. The main problem is that this is one-off code, which isn't reusable and took a bit of time to write. If only we could somehow leverage the expressive power of Underscore but still get the performance of the hand-written procedural solution...\n\n***\n\nThat's where Lazy.js comes in! Here's how we'd write the above query using Lazy.js:\n\n```javascript\nvar result = Lazy(array).map(square).map(inc).filter(isEven).take(5);\n```\n\nLooks almost identical, right? That's the idea: Lazy.js aims to be completely familiar to experienced JavaScript devs. Every method from Underscore should have the same name and identical behavior in Lazy.js, except that instead of returning a fully-populated array on every call, it creates a *sequence* object with an `each` method.\n\nWhat's important here is that **no iteration takes place until you call `each`**, and **no intermediate arrays are created**. Essentially Lazy.js combines all query operations into a sequence that behaves quite a bit like the procedural code we wrote a moment ago.\n\nOf course, *unlike* the procedural approach, Lazy.js lets you keep your code clean and functional, and focus on buliding an application instead of optimizing array traversals.\n\nFeatures\n--------\n\nOK, cool. What else can Lazy.js do?\n\n### Indefinite sequence generation\n\nThe sequence-based paradigm of Lazy.js lets you do some pretty cool things that simply aren't possible with Underscore's array-based approach. One of these is the generation of **indefinite sequences**, which can go on forever, yet still support all of Lazy's built-in mapping and filtering capablities.\n\nWant an example? Sure thing! Let's say we want 300 unique random numbers between 1 and 1000.\n\n```javascript\nvar uniqueRandsFrom1To1000 = Lazy.generate(function() { return Math.random(); })\n  .map(function(e) { return Math.floor(e * 1000) + 1; })\n  .uniq()\n  .take(300);\n\n// Output: see for yourself!\nuniqueRandsFrom1To1000.each(function(e) { console.log(e); });\n```\n\nPretty neat. How about a slightly more advanced example? Let's use Lazy.js to make a [Fibonacci sequence](http://en.wikipedia.org/wiki/Fibonacci_number).\n\n```javascript\nvar fibonacci = Lazy.generate(function() {\n  var x = 1,\n      y = 1;\n  return function() {\n    var prev = x;\n    x = y;\n    y += prev;\n    return prev;\n  };\n}());\n\n// Output: undefined\nvar length = fibonacci.length();\n\n// Output: [2, 2, 3, 4, 6, 9, 14, 22, 35, 56]\nvar firstTenFibsPlusOne = fibonacci.map(inc).take(10).toArray();\n```\n\nOK, what else?\n\n### Asynchronous iteration\n\nYou've probably [seen code snippets before](https://gist.github.com/dtao/2351944) that show how to iterate over an array asynchronously in JavaScript. But have you seen an example packed full of map-y, filter-y goodness like this?\n\n```javascript\nvar asyncSequence = Lazy(array)\n  .async(100) // specifies a 100-millisecond interval between each element\n  .map(inc)\n  .filter(isEven)\n  .take(20);\n\n// This function returns immediately and begins iterating over the sequence asynchronously.\nasyncSequence.each(function(e) {\n  console.log(new Date().getMilliseconds() + \": \" + e);\n});\n```\n\nAll right... what else?\n\n### Event sequences\n\nWith indefinite sequences, we saw that unlike Underscore and Lo-Dash, Lazy.js doesn't actually need an in-memory collection to iterate over. And asynchronous sequences demonstrate that it also doesn't need to do all its iteration at once.\n\nNow here's a really cool combination of these two features: with a small extension to Lazy.js (**lazy.dom.js**, a separate file to include in browser-based environments), you can apply all of the power of Lazy.js to **handling DOM events**. In other words, Lazy.js lets you think of DOM events as a *sequence*&mdash;just like any other&mdash;and apply the usual `map`, `filter`, etc. functions on that sequence.\n\nHere's an example. Let's say we want to handle all `mousemove` events on a given DOM element, and show their coordinates in one of two other DOM elements depending on location.\n\n```javascript\n// First we define our \"sequence\" of events.\nvar mouseEvents = Lazy.events(sourceElement, \"mousemove\");\n\n// Map the Event objects to their coordinates, relative to the element.\nvar coordinates = mouseEvents.map(function(e) {\n  var elementRect = sourceElement.getBoundingClientRect();\n  return [\n    Math.floor(e.clientX - elementRect.left),\n    Math.floor(e.clientY - elementRect.top)\n  ];\n});\n\n// For mouse events on one side of the element, display the coordinates in one place.\ncoordinates\n  .filter(function(pos) { return pos[0] < sourceElement.clientWidth / 2; })\n  .each(function(pos) { displayCoordinates(leftElement, pos); });\n\n// For those on the other side, display them in a different place.\ncoordinates\n  .filter(function(pos) { return pos[0] > sourceElement.clientWidth / 2; })\n  .each(function(pos) { displayCoordinates(rightElement, pos); });\n```\n\nAnything else? Of course!\n\n### String processing\n\nNow here's something you may not have even thought of: `String.match` and `String.split`. In JavaScript, each of these methods returns an *array* of substrings. If you think about it, this often means doing more work than necessary; but it's the quickest way (from a developer's standpoint) to get the job done.\n\nFor example, suppose you wanted the first five lines of a block of text. You could always do this:\n\n```javascript\nvar firstFiveLines = text.split(\"\\n\").slice(0, 5);\n```\n\nBut of course, this actually splits *the entire string* into every single line. If the string is very large, this is quite wasteful.\n\nIn lower-level languages&mdash;e.g. Java, C#&mdash; we have the notion of *streams*. A stream is not necessarily all read into memory. We can get something like that with Lazy.js by wrapping the string with `Lazy` and calling `split`:\n\n```javascript\nvar firstFiveLines = Lazy(text).split(\"\\n\").take(5);\n```\n\nThis way we can read the first five lines of an arbitrarily large string (without pre-populating a huge array) and map/reduce on it just as with any other sequence.\n\nSimilarly with `String.match`: let's say we wanted to find the first 5 alphanumeric matches in a string. With Lazy.js, it's easy!\n\n```javascript\nvar firstFiveWords = Lazy(text).match(/[a-z0-9]/i).take(5);\n```\n\nPiece of cake.\n\nAvailable functions\n-------------------\n\nCurrently the following functions are available (meaning you can call them on any `Lazy.Sequence` object, such as what you get back from `Lazy(array)`, `Lazy.generate`, `Lazy(string).split`, &c.):\n\n- `map`\n- `pluck`\n- `reduce` (aka `inject` or `foldl`)\n- `reduceRight` (aka `foldr`)\n- `filter`\n- `reject`\n- `where`\n- `invoke`\n- `find`\n- `findWhere`\n- `first` (aka `head` or `take`)\n- `rest` (aka `tail` or `drop`)\n- `initial`\n- `last`\n- `sortBy`\n- `groupBy`\n- `countBy`\n- `uniq`\n- `zip`\n- `concat`\n- `without`\n- `difference`\n- `union`\n- `intersection`\n- `flatten`\n- `compact`\n- `shuffle`\n- `every` (aka `all`)\n- `some` (aka `any`)\n- `indexOf`\n- `lastIndexOf`\n- `sortedIndex`\n- `contains`\n- `min`\n- `max`\n\nThis library is experimental and still a work in progress.\n",
  "readmeFilename": "README.md",
  "_id": "lazy.js@0.1.0",
  "dist": {
    "shasum": "f0e80489f46423a771b31e32d47fac41a7088069"
  },
  "_from": "lazy.js@",
  "_resolved": "https://registry.npmjs.org/lazy.js/-/lazy.js-0.1.0.tgz"
}
